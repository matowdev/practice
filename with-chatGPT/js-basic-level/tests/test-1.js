// JavaScript - basic Level
// Test 1

/*
Инструкция:
- Ответь на вопросы в этом файле.
- В теоретических вопросах выбери правильный вариант или напиши ответ в комментариях.
- В практических задачах напиши код.
- После завершения отправь файл обратно для проверки.
*/

// ---

// Часть 1: Теоретические вопросы

// 1. Основы JavaScript
// Какие из следующих утверждений о `var`, `let`, `const` верны?
// a) `var` имеет блочную область видимости.
// b) `let` можно переопределить, но нельзя повторно объявить в той же области видимости.
// c) `const` нельзя изменить после объявления.
// d) `var` не поддерживает поднятие (hoisting).

// Ответ: верны утверждения - b) и с)

// 2. Что выведет этот код и почему?
// console.log(typeof null);

// Ответ: если я не ошибаюсь этот код, выведет - "object", это обще признанная ошибка языка.. в какой то момент может делалась, для какой то совместимости.. говорил создатель языка (или это про другую ошибку..)

// ---

// 2. Функции
// 3. Какой синтаксис стрелочной функции верный?
// Выбери правильный вариант:
// a) let sum = (a, b) => return a + b;
// b) let sum = (a, b) => { return a + b };
// c) let sum = (a, b) => a + b;

// Ответ: верные варианты - b) и c)

// 4. В чем разница между `function declaration` и `function expression`?

// Ответ: разница есть и причём очень большая, т.е. `function declaration` и `function expression` это по сути способы объявления/инициализаций функций.. т.е. `function declaration` это объявление, через глобальное/ключевое слово function.. такое объявление всегда в первую очередь исчится в файле/при парсинге.. далее из этого формируется "call stack" - очередь вывозов, плюс такому объявление доступно всплытие или "hoisting", т.е. это когда мы можем вызывать функцию раньше чем она объявлена.. другим делом является `function expression` это есть присвоение функции как значения переменной, такой способ будет отрабатывать только тогда когда поток выполнения дойдёт вот прям непосредственно до этой/такой инициализации, т.е. только в этот момент.. соответственно говорить о попадании в изначальную "очередь вызовов" и о "hoisting".. не приходится.

// ---

// 3. Объекты
// 5. Чем отличается копирование объекта через `=` от `Object.assign()`?

// Ответ: изначально стоит уточнить, что объекты.. эти ссылочный тип хранения (т.е. это выделение в памяти конкретной ссылки для того иного объекта для хранения), понимая это/таким образом копирование объекта через `=` это по сути присвоение той же ссылки, т.е. при таком копировании все будут ссылаться на один объект (т.е. с повторением изменений, как в одном так и в других объектах).. копирование же посредствам `Object.assign()` исключает вроде вот это дублирование, но только для основного объекта.. т.е. если в нём есть ещё/другие вложенные объекты то они скопируются, как посредствам `=`.. для того что бы полностью разорвать связь, уёти от этих одних ссылок нужно импользовать/отрабатывать метод structuredClone().. если я не ошибаюсь.

// 6. Как проверить, есть ли свойство в объекте? (Написать два варианта)

// Ответ: сразу вспомнился метод in, типа ('honda' in cars).. а вот второй способ.. у объектов нет способа length.. второй вариант, не знаю.. вот так можно попробовать (cars.volvo != undefined)
// ! я не вспомнил метод/отработку hasOwnProperty():
// console.log(cars.hasOwnProperty('honda'));

// ---

// 4. Массивы и циклы
// 7. Какой из этих методов изменяет исходный массив?
// a) `map()`
// b) `filter()`
// c) `splice()`
// d) `slice()`

// Ответ: метод splice() изменяет исходный массив и при этом возвращает исключенной/удалённое значение

// 8. Чем отличается `for...of` от `for...in`?

// Ответ: это два отличных цикла.. `for...of` это в первую очередь для массивов (строк), с ним хорошо чтото итерировать.. а `for...in` хорош для объектов, он кстати возвращает строку.. по этому если применять к массиву чисел, то придётся переводить значение в числа.. а это соответственно, такое себе занятие..

// ---

// 5. DOM
// 9. Чем `querySelectorAll()` отличается от `getElementsByClassName()`?

// Ответ: основное отличие этих методов в том, какие они формирую коллекции, т.е. "живые" или "не живые", т.е. `querySelectorAll()` формирует "не живую" NodeList collection, а `getElementsByClassName()` формирует "живую" HTMLCollection.. это кстати массива подобные коллекции, но не полноценные к полноценным их ещё нужно приводить, если понадобиться отрабатывать все возможные методы для массивов.

// 10. Как программно создать элемент `<div>` и добавить его в `<body>`?

// Ответ: создать можно.. ну если по уму, то (кстати есть вариации как получить body):
// const bodyElement = document.querySelector('body');
// const divElement = document.createElement('div');
//
// bodyElement.append(divElement);

// ---

// Часть 2: Практические задания

// 1. Написание функций
// 11. Напиши функцию `isEven(n)`, которая принимает число и возвращает `true`, если оно четное, иначе `false`.
function isEven(n) {
  return n % 2 == 0;
}

console.log(isEven(2)); // true
console.log(isEven(3)); // false

// 12. Напиши функцию, которая принимает строку и возвращает её без гласных букв.
function removeVowels(str) {
  const vowels = 'aeiouy';
  const newStr = str.toLowerCase().split('');

  return newStr.filter((letter) => !vowels.includes(letter)).join('');
}

console.log(removeVowels('QsGHVeiovNFG')); // 'qsghvvnfg'
console.log(removeVowels('NwewitiypojgHGseqa')); // 'nwwtpjghgsq'

// ---

// 2. Работа с объектами
// 13. Напиши функцию `countProperties(obj)`, которая возвращает количество свойств в объекте.
const person = {
  name: 'Sergey',
  age: 37,
  family: true,
};

function countProperties(obj) {
  let count = 0;

  for (const prop in obj) {
    count++;
  }

  return count;
}

// ? ChatGPT рекомендовал отрабатывать Object.keys(obj).length типа/сразу и всё:
// return Object.keys(obj).length;

console.log(countProperties(person)); // 3

// 14. Дана строка в формате JSON. Напиши код, который превращает её в объект.
const jsonString = '{"name": "John", "age": 30}';
const obj = JSON.parse(jsonString);

console.log(obj); // {name: 'John', age: 30}

// ---

// 3. Работа с массивами
// 15. Дан массив чисел. Напиши код, который удаляет из него дубликаты.
const numbers = [1, 2, 3, 3, 4, 5, 5, 6];
const unduplicatedArr = [];

for (let i = 0; i < numbers.length; i++) {
  if (!unduplicatedArr.includes(numbers[i])) {
    unduplicatedArr.push(numbers[i]);
  }
}

console.log(unduplicatedArr); // [1, 2, 3, 4, 5, 6]

// 16. Напиши код, который сортирует массив строк по алфавиту.
const words = ['banana', 'apple', 'cherry'];

console.log(words.sort((a, b) => a.localeCompare(b) - b.localeCompare(a))); // ['apple', 'banana', 'cherry']

// ? ChatGPT рекомендовал так отрабатывать (типа.. разница вычитания тут не нужна):
words.sort((a, b) => a.localeCompare(b));

// ---

// 4. Работа с асинхронностью
// 17. Напиши `async` функцию, которая делает `fetch`-запрос по URL и возвращает JSON-ответ.
async function fetchData(url) {
  try {
    const response = await fetch(url);

    if (response.ok) {
      const data = await response.json();
      return data;
    } else {
      throw new Error(`Ошибка: ${response.status}!`);
    }
  } catch (err) {
    console.error(err);
  }
}

// 18. Как правильно обработать ошибку в `fetch` запросе?
try {
  if (!response.ok) {
    throw new Error(`Ошибка: ${response.status}!`);
  }
} catch (err) {
  console.error(err);
}
